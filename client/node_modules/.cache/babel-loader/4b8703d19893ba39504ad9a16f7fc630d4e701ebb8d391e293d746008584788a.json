{"ast":null,"code":"import calculateWinner from './calculateWinner';\n\n/**\r\n * Minimax 알고리즘을 사용하여 컴퓨터의 최적 수를 계산\r\n * @param {('X' | 'O' | null)[]} board 현재 보드 상태\r\n * @param {boolean} isMaximizing 컴퓨터의 차례면 true, 아니면 false\r\n * @returns {number} 최적의 위치 인덱스\r\n */\nfunction minimax(board, depth, isMaximizing) {\n  const winner = calculateWinner(board);\n  if (winner) {\n    if (winner.winner === 'O') return 10 - depth; // 컴퓨터 승리\n    if (winner.winner === 'X') return depth - 10; // 사람 승리\n    return 0; // 무승부\n  }\n  if (isMaximizing) {\n    let bestScore = -Infinity;\n    let move = -1;\n    for (let i = 0; i < board.length; i++) {\n      if (!board[i]) {\n        // 빈 칸에 대해 가능한 수를 둠\n        board[i] = 'O';\n        const score = minimax(board, depth + 1, false);\n        board[i] = null;\n        if (score > bestScore) {\n          bestScore = score;\n          move = i;\n        }\n      }\n    }\n    return move;\n  } else {\n    let bestScore = Infinity;\n    for (let i = 0; i < board.length; i++) {\n      if (!board[i]) {\n        board[i] = 'X';\n        const score = minimax(board, depth + 1, true);\n        board[i] = null;\n        if (score < bestScore) {\n          bestScore = score;\n        }\n      }\n    }\n    return bestScore;\n  }\n}\n\n/**\r\n * 현재 보드 상태에서 컴퓨터의 최적 수를 반환\r\n * @param {('X' | 'O' | null)[]} board 현재 보드 상태\r\n * @returns {number} 최적의 수의 인덱스\r\n */\nexport function calculateBestMove(board) {\n  return minimax(board, 0, true);\n}","map":{"version":3,"names":["calculateWinner","minimax","board","depth","isMaximizing","winner","bestScore","Infinity","move","i","length","score","calculateBestMove"],"sources":["C:/tic-tac-toe/client/src/utils/calculateBestMove.ts"],"sourcesContent":["import calculateWinner from './calculateWinner';\r\n\r\n/**\r\n * Minimax 알고리즘을 사용하여 컴퓨터의 최적 수를 계산\r\n * @param {('X' | 'O' | null)[]} board 현재 보드 상태\r\n * @param {boolean} isMaximizing 컴퓨터의 차례면 true, 아니면 false\r\n * @returns {number} 최적의 위치 인덱스\r\n */\r\nfunction minimax(board: ('X' | 'O' | null)[], depth: number, isMaximizing: boolean): number {\r\n  const winner = calculateWinner(board);\r\n  if (winner) {\r\n    if (winner.winner === 'O') return 10 - depth; // 컴퓨터 승리\r\n    if (winner.winner === 'X') return depth - 10; // 사람 승리\r\n    return 0; // 무승부\r\n  }\r\n\r\n  if (isMaximizing) {\r\n    let bestScore = -Infinity;\r\n    let move = -1;\r\n    for (let i = 0; i < board.length; i++) {\r\n      if (!board[i]) { // 빈 칸에 대해 가능한 수를 둠\r\n        board[i] = 'O';\r\n        const score = minimax(board, depth + 1, false);\r\n        board[i] = null;\r\n        if (score > bestScore) {\r\n          bestScore = score;\r\n          move = i;\r\n        }\r\n      }\r\n    }\r\n    return move;\r\n  } else {\r\n    let bestScore = Infinity;\r\n    for (let i = 0; i < board.length; i++) {\r\n      if (!board[i]) {\r\n        board[i] = 'X';\r\n        const score = minimax(board, depth + 1, true);\r\n        board[i] = null;\r\n        if (score < bestScore) {\r\n          bestScore = score;\r\n        }\r\n      }\r\n    }\r\n    return bestScore;\r\n  }\r\n}\r\n\r\n/**\r\n * 현재 보드 상태에서 컴퓨터의 최적 수를 반환\r\n * @param {('X' | 'O' | null)[]} board 현재 보드 상태\r\n * @returns {number} 최적의 수의 인덱스\r\n */\r\nexport function calculateBestMove(board: ('X' | 'O' | null)[]): number {\r\n  return minimax(board, 0, true);\r\n}\r\n"],"mappings":"AAAA,OAAOA,eAAe,MAAM,mBAAmB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,OAAOA,CAACC,KAA2B,EAAEC,KAAa,EAAEC,YAAqB,EAAU;EAC1F,MAAMC,MAAM,GAAGL,eAAe,CAACE,KAAK,CAAC;EACrC,IAAIG,MAAM,EAAE;IACV,IAAIA,MAAM,CAACA,MAAM,KAAK,GAAG,EAAE,OAAO,EAAE,GAAGF,KAAK,CAAC,CAAC;IAC9C,IAAIE,MAAM,CAACA,MAAM,KAAK,GAAG,EAAE,OAAOF,KAAK,GAAG,EAAE,CAAC,CAAC;IAC9C,OAAO,CAAC,CAAC,CAAC;EACZ;EAEA,IAAIC,YAAY,EAAE;IAChB,IAAIE,SAAS,GAAG,CAACC,QAAQ;IACzB,IAAIC,IAAI,GAAG,CAAC,CAAC;IACb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,KAAK,CAACQ,MAAM,EAAED,CAAC,EAAE,EAAE;MACrC,IAAI,CAACP,KAAK,CAACO,CAAC,CAAC,EAAE;QAAE;QACfP,KAAK,CAACO,CAAC,CAAC,GAAG,GAAG;QACd,MAAME,KAAK,GAAGV,OAAO,CAACC,KAAK,EAAEC,KAAK,GAAG,CAAC,EAAE,KAAK,CAAC;QAC9CD,KAAK,CAACO,CAAC,CAAC,GAAG,IAAI;QACf,IAAIE,KAAK,GAAGL,SAAS,EAAE;UACrBA,SAAS,GAAGK,KAAK;UACjBH,IAAI,GAAGC,CAAC;QACV;MACF;IACF;IACA,OAAOD,IAAI;EACb,CAAC,MAAM;IACL,IAAIF,SAAS,GAAGC,QAAQ;IACxB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,KAAK,CAACQ,MAAM,EAAED,CAAC,EAAE,EAAE;MACrC,IAAI,CAACP,KAAK,CAACO,CAAC,CAAC,EAAE;QACbP,KAAK,CAACO,CAAC,CAAC,GAAG,GAAG;QACd,MAAME,KAAK,GAAGV,OAAO,CAACC,KAAK,EAAEC,KAAK,GAAG,CAAC,EAAE,IAAI,CAAC;QAC7CD,KAAK,CAACO,CAAC,CAAC,GAAG,IAAI;QACf,IAAIE,KAAK,GAAGL,SAAS,EAAE;UACrBA,SAAS,GAAGK,KAAK;QACnB;MACF;IACF;IACA,OAAOL,SAAS;EAClB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASM,iBAAiBA,CAACV,KAA2B,EAAU;EACrE,OAAOD,OAAO,CAACC,KAAK,EAAE,CAAC,EAAE,IAAI,CAAC;AAChC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}