{"ast":null,"code":"/**\r\n * calculateWinner - 주어진 게임판에서 승리자를 계산하는 함수.\r\n * \r\n * @param squares - 각 칸에 'X', 'O', 또는 null이 들어있는 배열 (게임 보드 상태)\r\n * @returns { winner: 'X' | 'O', winningSquares: number[] } | null\r\n *   - 승자가 있으면 승리자와 승리한 칸의 인덱스를 반환하고,\r\n *   - 승자가 없으면 null을 반환.\r\n */\nconst calculateWinner = squares => {\n  // 승리 가능한 모든 라인의 인덱스를 정의한 배열\n  const lines = [[0, 1, 2],\n  // 첫 번째 행\n  [3, 4, 5],\n  // 두 번째 행\n  [6, 7, 8],\n  // 세 번째 행\n  [0, 3, 6],\n  // 첫 번째 열\n  [1, 4, 7],\n  // 두 번째 열\n  [2, 5, 8],\n  // 세 번째 열\n  [0, 4, 8],\n  // 대각선 (왼쪽 위에서 오른쪽 아래)\n  [2, 4, 6] // 대각선 (오른쪽 위에서 왼쪽 아래)\n  ];\n\n  // 각 승리 라인에 대해 승자가 있는지 확인\n  for (let i = 0; i < lines.length; i++) {\n    const [a, b, c] = lines[i]; // 한 줄에 해당하는 세 개의 인덱스를 가져옴\n\n    // 세 개의 칸이 모두 같은 값('X' 또는 'O')이고 null이 아닐 때 승자 결정\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return {\n        winner: squares[a],\n        // 승리한 플레이어 ('X' 또는 'O')\n        winningSquares: [a, b, c] // 승리한 칸들의 인덱스\n      };\n    }\n  }\n\n  // 승자가 없으면 null 반환\n  return null;\n};\nexport default calculateWinner;","map":{"version":3,"names":["calculateWinner","squares","lines","i","length","a","b","c","winner","winningSquares"],"sources":["C:/tic-tac-toe/client/src/utils/calculateWinner.ts"],"sourcesContent":["/**\r\n * calculateWinner - 주어진 게임판에서 승리자를 계산하는 함수.\r\n * \r\n * @param squares - 각 칸에 'X', 'O', 또는 null이 들어있는 배열 (게임 보드 상태)\r\n * @returns { winner: 'X' | 'O', winningSquares: number[] } | null\r\n *   - 승자가 있으면 승리자와 승리한 칸의 인덱스를 반환하고,\r\n *   - 승자가 없으면 null을 반환.\r\n */\r\nconst calculateWinner = (squares: ('X' | 'O' | null)[]) => {\r\n    // 승리 가능한 모든 라인의 인덱스를 정의한 배열\r\n    const lines = [\r\n        [0, 1, 2],  // 첫 번째 행\r\n        [3, 4, 5],  // 두 번째 행\r\n        [6, 7, 8],  // 세 번째 행\r\n        [0, 3, 6],  // 첫 번째 열\r\n        [1, 4, 7],  // 두 번째 열\r\n        [2, 5, 8],  // 세 번째 열\r\n        [0, 4, 8],  // 대각선 (왼쪽 위에서 오른쪽 아래)\r\n        [2, 4, 6],  // 대각선 (오른쪽 위에서 왼쪽 아래)\r\n    ];\r\n\r\n     // 각 승리 라인에 대해 승자가 있는지 확인\r\n    for (let i = 0; i < lines.length; i++) {\r\n        const  [a, b, c] = lines[i]; // 한 줄에 해당하는 세 개의 인덱스를 가져옴\r\n\r\n        // 세 개의 칸이 모두 같은 값('X' 또는 'O')이고 null이 아닐 때 승자 결정\r\n        if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\r\n            return { \r\n                winner: squares[a], // 승리한 플레이어 ('X' 또는 'O')\r\n                winningSquares:[a, b, c] // 승리한 칸들의 인덱스\r\n            };\r\n        }\r\n    }\r\n    \r\n    // 승자가 없으면 null 반환\r\n    return null;\r\n}\r\n\r\nexport default calculateWinner;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,eAAe,GAAIC,OAA6B,IAAK;EACvD;EACA,MAAMC,KAAK,GAAG,CACV,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAAG;EACZ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAAG;EACZ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAAG;EACZ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAAG;EACZ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAAG;EACZ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAAG;EACZ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAAG;EACZ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAG;EAAA,CACf;;EAEA;EACD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,KAAK,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IACnC,MAAO,CAACE,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAGL,KAAK,CAACC,CAAC,CAAC,CAAC,CAAC;;IAE7B;IACA,IAAIF,OAAO,CAACI,CAAC,CAAC,IAAIJ,OAAO,CAACI,CAAC,CAAC,KAAKJ,OAAO,CAACK,CAAC,CAAC,IAAIL,OAAO,CAACI,CAAC,CAAC,KAAKJ,OAAO,CAACM,CAAC,CAAC,EAAE;MACtE,OAAO;QACHC,MAAM,EAAEP,OAAO,CAACI,CAAC,CAAC;QAAE;QACpBI,cAAc,EAAC,CAACJ,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,CAAC;MAC7B,CAAC;IACL;EACJ;;EAEA;EACA,OAAO,IAAI;AACf,CAAC;AAED,eAAeP,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}